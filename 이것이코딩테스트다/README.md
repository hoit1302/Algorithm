# 이것이 코딩 테스트다.
나동빈 지음

## 2-03 그리디
코테나 알고리즘 대회에서 가장 난이도가 낮은 1~2번 문제는 대부분 그리디 또는 구현 문제이다.

난이도가 낮은 만큼 합격을 좌우하기도 하는 중요한 유형이다.
## 2-04 구현
피지컬이 중요하다. 다양한 문제를 접하면서 꾸준히 풀어보아야 한다.

## 2-05 DFS/BFS
재귀 함수는 스택 자료구조와 동일하다. 스택 자료구조를 활용해야하는 dfs 알고리즘은 **재귀함수**를 이용해서 간편하게 구현될 수 있다.

bfs는 현재까지 공부한대로라면 아래의 문장을 이해했으므로 암기해두면 된다.
```
큐에서 가장 앞의 원소를 꺼내
4 방향으로 (for loop)
변경된 위치에서
벽이면 무시하고
방문하지 않은 원소들의 위치를
큐에 삽입
방문했음, cost 기록
```

## 2-06 정렬
코테에서 정렬 알고리즘이 사용되는 경우, 일반적으로 3가지 유형으로 나눌 수 있다.
1. **정렬 라이브러리로 풀 수 있는 문제**: 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
2. **정렬 알고리즘의 원리에 대해서 물어보는 문제**: 선택 정렬, 삽입 정렬, 퀵 정렬 등
3. **더 빠른 정렬이 필요한 문제**: 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

## 2-07 이진 탐색
이진 탐색은 코딩 테스트에서 단골로 나오는 문제이고, 이진 탐색의 소스코드를 백지에서 작성하는 것은 상당히 어려운 작업일 수 있다.

<u>**그러므로 가급적 외워야한다.**</u>

구현하는 방법은 재귀 함수와 반복문을 두 가지가 있다.

탐색 범위가 2000만을 넘어가거나 처리해야 할 데이터의 개수나 값이 1000만 단위 이상으로 넘어가면 이진 탐색과 같이 O(logN) 의 속도를 내야하는 알고리즘을 떠올려보자.

쉽게 말해, 큰 수를 보면 당연하다는 듯이 가장 먼저 이진 탐색을 떠올리면 된다.

밑이 2인 로그
log1,000,000 = 거의 20
log2,000,000,000 = 거의 30

코테나 프로그래밍 대회에서 파라메트릭 서치 (parametric search) 유형의 문제는 보통 이진 탐색을 이용하여 해결한다.

parametric search는 최적화 문제를 결정 문제로 바꾸어 해결하는 기법이다. 원하는 조건을 만족하는 가장 알맞는 값을 찾는 문제에 주로 사용한다.

이 유형은 굉장히 헷갈리는데, 나만의 언어가 있다면
```markdown
답으로 도출해야하는 값이 훅 작아졌다가 슬슬슬 커져야 함.
-> 슬슬슬 커지는 부분에서 일단 res 담아두면서 left 갱신하기!

기본적으로 이진 탐색은 while (l <= r) 로 시작함!
그 다음 바로 mid 갱신해주고
세부적인 코딩을 하게 됨.
```

## 2-08 다이나믹 프로그래밍
### 언제 사용할까?
아래의 두 조건을 모두 만족할 때 사용할 수 있다.
1. 큰 문제를 작은 문제로 나눌 수 있고
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

**메모이제이션 (memoization) 기법** (caching 이라고도 한다): 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하여 메모한 결과를 다시 그대로 가져오는 기법을 의미한다.

### 분할 정복 vs dp
큰 문제를 작은 문제로 나눈 방법은 퀵 정렬에서도 동일한데, 퀵 정렬은 분할 정복 알고리즘으로 분류된다.

두 알고리즘의 차이는 크고 작은 문제들이 서로서로 영향을 미치고 있냐이다.

분할 정복 중 퀵 정렬로 예를 들면, 한 번 기준을 한 피벗 원소가 자리를 잡게 되면 그 원소의 위치는 바뀌지 않고, 그 원소의 자리를 다시 처리하는 부분 문제는 존재하지 않는다.

하지만 dp는 한 번 해결했던 문제를 다시 해결한다는 점이 특징이다. 그렇기 때문에 이미 해결된 부분 문제에 대한 답을 저장해 놓고, 해당 계산 결과 값을 원할 때 다시 해결할 필요가 없다고 바로 반환하는 것이다.

### 구현 방법: 반복문 vs 재귀 함수 
재귀 함수를 이용하면 top-down 방식(하향식)이라고 부르고, 반복문을 이용하면 bottom-up 방식(상향식) 이라고 부른다.

일반적으로 반복문을 이용한 다이나믹 프로그램이 더 성능이 좋다. 재귀 함수의 경우 함수를 다시 호출했을 때 메모리 상에 적재되는 오버헤드가 발생하기 때문이다. 

## 2-09 최단 거리

최단 거리 알고리즘은 보통 다익스트라 최단 경로 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘 이렇게 3가지를 사용한다.

그 중에서도 다익스트라, 플-워 이 2가지가 코테에서 많이 등장하는 유형이다.

### 다익스트라 최단 경로 알고리즘

**언제**: 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우

**공간**: 각 노드에 대한 현재까지의 최단 거리를 **1차원 배열**에 저장하고 최솟값으로 갱신한다.

**그리디**: 방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인함. 

**우선순위큐**: 각 단계에서 최단 거리가 가장 짧은 노드를 선택하는 과정에서 우선순위 큐를 활용한다. 비용이 적은 노드를 우선 방문해야하므로 최소 힙을 사용해야 한다.

우선순위큐 팁: C++은 기본적으로 최대 힙으로 라이브러리가 구현되어있다. 최소 힙을 최대 힙처럼 사용하기 위해서 일부로 우선순위에 해당하는 값을 음수 부호를 붙여서 넣었다가 나중에 우선순위 큐에서 꺼낸 다음에 다시 음수 부호를 붙여서 원래의 값으로 돌리는 방식을 사용할 수 있다.

**시간 복잡도**: O(ElogV), E개의 원소를 우선순위 큐에 넣었다가 모두 빼내는 연산과 매우 유사함. 이 때 중복 간선을 포함하지 않는 경우 항상 E < V^2(모든 노드끼리 다 연결된 경우)을 만족하므로.

내가 코드 작성할 때 주의할 점: 우선순위 큐 다루기 쉽게 (그래프 간선 저장)과 (우선순위 큐)에서 cost 값이 먼저오도록 !!!
```c++
#define cost first
#define vxt second
```

### 플로이드 워셜 알고리즘

**언제**: 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야하는 경우

**공간**: **2차원 배열**을 최단 거리 정보를 저장한다.

**dp, 점화식**: A에서 B로 가는 최소 비용과 A에서 K를 거쳐 B로 가는 비용을 비교해 더 작은 값으로 갱신해준다. 

**초기값**: int일 경우 1e9를 무한으로 설정해 모든 값을 무한으로 설정해주고 최솟값을 찾아 나간다.

**시간 복잡도**: 노드의 개수가 N개일 때, 거쳐가는 노드가 총 N개이고 각 한 번의 단계마다 출발지부터 도착지까지 N^2의 경우가 있으므로 **O(N^3)** 이다.
