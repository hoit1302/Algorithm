<div align="center">

# 프로그래머스 문제들 뽀개기

## 2022 KAKAO TECH INTERNSHIP

</div>

### 문제 3번 [코딩 테스트 공부](https://school.programmers.co.kr/learn/courses/30/lessons/118668)

**접근법**

완전 탐색으로 풀이 시 시간 복잡도를 계산해보면

특정 알고력과 코딩력을 가지고 있을 때 (150^2) 알고력을 높이는 공부와 코딩력 높이는 공부와 문제들을 푸는 선택(1+1+100)을 할 수 있다.

대략 225e4의 값이 나와서 완탐으로 풀이할 수 있지 않을까 라고 생각하기 쉽지만 효율성 부분에서 점수를 얻지 못한다.

이 문제를 보고 dp라고 판단하는 것이 어려운 것 같다. 고수들의 설명을 여러 개 찾아보았는데 경험에 의한 감으로 표현했다.   

접근법도 어려운데 생각보다 다루어야할 코너케이스가 꽤 있다.

**첫 번째 시도**

틀린 이유

`알고력 또는 코딩력 1을 놉이기 위해 1의 시간이 필요하다`는 조건은 DP 배열을 업데이트하는데 필요한 조건이다.

```c++
for (int i = alp; i <= a_max; i++) for (int j = cop; j <= c_max; j++) {
    dp[i][j] = (i - alp) + (j - cop);
}
```

나는 초기화할 때 수 많은 경우 중 한 가지 경우로 정해버렸기 때문에 완전히 틀린 방식이다.

**내가 어려웠던 부분 & 찾아서 배운 부분**

1. dp 배열 크기 지정
   - 접근 범위 파악하기
2. 알고력과 코딩력을 모두 충족했을 때 가지치기
3. 초기알고력이 목표알고력보다 더 큰 경우 (코딩력도 마찬가지)
4. dp 배열을 초기화하는 범위
5. dp 배열 갱신 시 목표치를 넘는 한 파워에만 집중해 다른 한 파워에 리워드를 추가하지 않은 것 (대삽질, 1시간 걸림) 

도움을 많이 받은 설명: https://taehoung0102.tistory.com/211

### 문제 4번 [등산 코스 정하기](https://school.programmers.co.kr/learn/courses/30/lessons/118669)

**첫 번째 시도**

**DFS로 풀이, 35분 걸림, 45.2점. 반절 이상은 TLE**

- DFS와 BFS의 시간 복잡도는 인접행렬로 구현했을 때 O(V^2), 인접리스트로 구현했을 때 O(V+E)의 시간복잡도를 갖는다.
- 각 시작점 최대 5만개에 대해서 DFS를 수행하게 되면 O(5e4 * 25e4) 당연히 시간 초과가 난다.
- 이 부분에 대해서 명확히 인지했다면 많은 시간을 줄였을 것이다. 잘 기억하자.

**두 번째 시도**

**MST - Kruskal로 풀이, 구현 시간만 어림잡아 1시간, 87.1점.**

- `intensity가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스를 선택합니다.`이 조건을 풀이하지 못했다.
- 잘못된 접근

**세 번째 시도**

**다익스트라로 풀이.**

- 카카오의 공식 해설과 몇 블로그의 글만 읽고 내가 작성해두었던 개념 노트를 참고해 구현해서 맞음
- **다익스트라 알고리즘만 정확히 이해하고 있으면 조금만 응용해서 풀 수 있다**고 한다.
- **임의의 출입구 A에서 어느 산봉우리로 가야 intensity가 최소가 되는지**로 기본 다익스트라를 변형시켰다.
- `출입구는 처음과 끝에 한 번씩, 산봉우리는 한 번만 포함되어야 합니다.`
  - 이 조건은 양방향 그래프를 단방향 그래프로 바꾸어 다루는 아이디어가 필요했다.

**여담**

해설을 읽으면서 알고리즘 문제를 풀 때 변수에 대해 더 명확한 설명과 정의가 필요하다는 것을 깨닫는다. 또한 구현하는 로직을 말하면서 코드를 작성하는 연습을 꾸준히 해야겠다.

<div align="center">

## 2022 KAKAO BLIND RECRUITMENT

</div>

### 문제 1번 [신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)

27분 소요

자료 구조 설정하고 다루는데 버벅거렸다. 여전히 cpp이 손이 안 익는 느낌이다...

공백을 기준으로 문자열 자르는 방법을 처음 배웠다. (`stringstream`, `#include <sstream>`) 

### 문제 2번 [k진수에서 소수 개수 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/92335)

소수 문제는 당연히 에라토스테네스의 체를 활용한다고 생각한 나의 고정관념을 깨부신 문제

40분동안 고민함... 문제를 자세히 봐야한다.

최대 N = 1000000을 가장 작은 진수인 3진수로 표현했을 때 13자리이다.

13자리의 숫자까지 에라토스테네스의 체로 소수인지 판별하면 공간복잡도와 시간복잡도 모두 초과한다.

이 문제는 소수 판별 호출 횟수가 매우 적기 때문에 < 13 숫자가 들어올 때마다 소수인지 판별하는 것이 적합한 해이다.

다만 N = 1e13이 될 수 있으므로 나누는 수를 2부터 √𝑁까지 살펴보는 O(√𝑁) 방법으로 소수 판정해야 한다.

### 문제 3번 [주차 요금 계산](https://school.programmers.co.kr/learn/courses/30/lessons/92341)

너가 생각하는 cpp 문법이 맞다. 조금 더 호다닥 작성해보자!

map의 value로 vector를 사용하고 싶단 생각을 많이 했다. 

검색해보니 사용할 수가 있다. 다시 바꿔서 작성해보자

### 문제 4번 [양궁 대회](https://school.programmers.co.kr/learn/courses/30/lessons/92342)

중복 조합 H(11, 10): 11개의 점수 종류를 중복해서 최대 10번 선택

중복 조합을 구현하고 싶었지만 `prev_permutation`을 조합으로 사용했을 경우 C(11*10, 10) (> 1억) 시간 초과가 된다.

라이언이 어피치의 화살보다 더 많이 맞춰 점수를 가져감 / 포기함 2가지 경우로 바라볼 수 있다.

점수의 종류는 0~10, 11가지가 되므로 최대 2^11 = 2048가지를 확인해보면 된다.

백트래킹으로 쉽게 틀을 짤 수 있다.

동점의 차이가 날 때 `낮은 점수를 더 많이 맞힌 경우를 반환`해야한다는 조건은 이렇게 처리할 수 있다.

```
코드 내 isNeedChange() 에 대한 내용이다.

낮은 점수의 화살 개수부터 확인한다.
기존 정답 점수판와 새로운 점수판의 화살 개수가 처음으로 차이날 때, 
if 새로운 점수판 개수가 더 많으면 정답을 새로운 점수판으로 바꾼다.
else 아니면 바꾸지 않는다.
```

### 문제 5번 [양과 늑대](https://school.programmers.co.kr/learn/courses/30/lessons/92343)

-> 큰 좌절감을 준 문제...🤯

**문제1.** dfs로 모든 경우를 탐색할 수 있다는 사실을 직감적으로 이해가 잘 안된다.

응용 백트래킹 문제를 더 풀어봐야할 것 같다.

**문제2.** 시간 복잡도를 어떻게 계산하는걸까?

정말 잘 모르겠다...

이 문제는 경로를 기억하지 않아도 된다.

방문한 노드를 제외하고 다음에 방문할 수 있는 노드로 완전 탐색을 수행한다.

**문제3.** for 루프를 돌며 초기화해야한다는 힌트를 이해못했다.

0은 1과 8을 자식으로 가지고 있다.



1로 나아갔을 때

- 기존에 갈 수 있었던 [1, 8] 배열에서 1을 없애고

- 1의 자식인 2, 4를 배열에 추가해

- 다음에 방문할 수 있는 정점 배열에 [2, 4, 8]를 기록해 호출한다.

반대로 8로 나아갔을 때

- 기존에 갈 수 있었던 [1, 8] 배열에서 8을 없애고

- 8의 자식인 7, 9를 배열에 추가해

- 다음에 방문할 수 있는 정점 배열에 [1, 7, 9]를 기록해 호출한다.

**여담**

카카오 공식 해설은 이 DFS 풀이를 설명했다.

하지만 [링크의 첫번째 슬라이드](https://blog.encrypted.gg/1029)에서 설명하듯이 상태의 중복이 발생하기 때문에 백트래킹 풀이는 시간 초과가 나야한다고 한다.

`비트마스킹을 사용해 확장된 상태 공간에서의 flood fill` 이라고 한다.

이것도 다시 풀이해봐야할 풀이로 두겠다.

### 문제 6번 [파괴되지 않은 건물](https://school.programmers.co.kr/learn/courses/30/lessons/92344)

**접근**

문제 주어진 대로 구현하면 O(N * M * K), N <= 1000, M <= 1000, K (skill 개수) <= 250000로 시간복잡도를 훌쩍 넘는다.

누적합을 이용하여 효율성을 높여야한다.

[공식 해설](https://tech.kakao.com/2022/01/14/2022-kakao-recruitment-round-1/#%EB%AC%B8%EC%A0%9C-6-%ED%8C%8C%EA%B4%B4%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B1%B4%EB%AC%BC)에 너무 잘 정리되어 있다.

```
(x1,y1)부터 (x2,y2)까지 n만큼의 변화는 (x1,y1)에 +n, (x1,y2+1)에 -n, (x2+1,y1)에 -n, (x2+1,y2+1)에 +n을 한 것과 같습니다.
이후 초기화된 값들로 위에서 아래로 한 번 누적해서 더해주고 왼쪽에서 오른쪽으로 다시 한 번 누적해서 더해주면 각 좌표의 최종 변화량이 저장됩니다.  
```

- 각 좌표의 최종 변화량 구하기: O(K)

- 누적합, 최종 변화량 보드에 적용하기: O(N * M)

-> O(K + N * M)

**문법적으로 버벅거린 부분**

```c++
// vector의 장점, 2차원 벡터 복사가 쉬움! 믿고 써라
vector<vector<int>> b;
b.assign(board.begin(), board.end()); 
```

**2 * 2 경우의 수 구현할 때**

a가 범위를 넘음, 넘지 않음
b가 범위를 넘음, 넘지 않음
이렇게 2 * 2 가지 구현할 때 항상 생각보다 시간이 소요된다.

```c++
1. a와 b가 safe한 경우 -> (a,b) 처리
2. a가 safe한 경우 -> (a) 처리
3. b가 safe한 경우 -> (b) 처리
4. a와 b 모두 safe하지 않은 경우 -> () 처리
```
<div align="center">

## 2021 KAKAO BLIND RECRUITMENT

</div>

### 문제 1번 [신규 아이디 추천](https://school.programmers.co.kr/learn/courses/30/lessons/72410)

30분 소요, 시간을 더 줄였으면 좋겠다! 더 많은 문자열 연습이 필요함.

step 3: 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.

-> 첫번째 .은 추가하고 이후 연속해서 . 이 나오면 무시하도록 로직 작성함.

step 4: new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다. 

-> s = s.substr(시작점, 원하는 길이) 활용하기

### 문제 2번 [메뉴 리뉴얼](https://school.programmers.co.kr/learn/courses/30/lessons/72411)

1. 각 주문의 모든 메뉴 조합을 구하면서 빈도수를 저장한다.
   - 조합
     - 20명, 한 명 당 10개까지 주문할 수 있음. 
     - 2^10 - 1개의 메뉴 조합 -> 20 * 2^10-1 = 20460 
     - 이 때, 메뉴 조합을 구하기 위해 이진법을 활용
     - <img width=360px src="https://user-images.githubusercontent.com/68107000/191903318-371828ad-bce6-4601-9990-e3986e655a5e.jpg"/>
   - 빈도수 저장
     - 각 메뉴 조합의 개수를 세야할 때 map을 활용한다. O(NlogN) 가능
     - 문제 두 번째 표를 자료구조로 옮기면 `map<int, string> freq[11]`
2. 각 메뉴 조합 종류 수마다 최대 빈도 값이 있을 것이다. 최대 빈도를 가진 메뉴 조합을 정답 배열에 추가해준 뒤 정답 배열을 정렬한다.
   - 3메뉴 코스 요리 중에는: ("ACD", 2회), ("ACE", 4회), ("ADE", 4회) -> 최대 빈도 값이 4이고 최대빈도값을 가진 "ACE", "ADE"만을 정답 배열에 추가함.

느낀 점: 문제가 이해하기 참 어렵다.

팁: 카카오 문제는 문제를 꼼꼼히 읽으면 자료 구조에 대한 힌트를 얻을 수 있다.

### 문제 3번 [순위 검색](https://school.programmers.co.kr/learn/courses/30/lessons/72412)

map<string, vector<int>> 자료형을 사용해서 3*2*2*2 가지의 key 값에 해당하는 스코어를 저장한 뒤

쿼리에서 요구하는 key 값들을 구하고 이분 탐색 (`lower_bound`)으로 찾는 문제

자료구조 아이디어, 조합(재귀), 이분 탐색의 지식을 잘 갖추고 있어야 풀이할 수 있는 문제였다.

lower_bound는 전에도 익혔는데 전혀 떠오르지 않았다. 꼭 기억해두자.

### 문제 4번 [합승 택시 요금](https://school.programmers.co.kr/learn/courses/30/lessons/72413)

30분 소요, 대박... 한 번에 맞았다 🥲😭

최대 범위 조심

- 19900 (간선의 수) * 1e5 (택시 요금) = 19억 9천만 < 21억 (int 범위)
- int 범위 내이지만 주의해서 무한의 값을 20억정도로 잡아야함.

s, a, b를 시작점으로 각각 다익스트라 수행 후 각 정점까지 합승할 때의 택시 요금을 비교해 최저 택시 요금을 찾아냄.

시간 복잡도

- O(3 * (VlogV + ElogV) + 200)

## 2021 Dev-Matching: 웹 백엔드 개발자(상반기)

### 2. 행렬 테두리 회전하기

풀이시간: 32분, 배열을 한 칸씩 이동시키는 로직 작성
단순한 로직이지만 자칫 잘못하면 시간이 오려걸림. 
여러 번 생각해보면서 익숙하게 만들자

```c++
void rotate(vector<ci> &arr) { // 회전할 길대로 좌표를 넣어둠.
    int dis, pre = g[arr[0].first][arr[0].second];
    for (int i = 1; i < arr.size(); i++) {
        int x2 = arr[i].first, y2 =  arr[i].second;
        dis = g[x2][y2]; // 2. (x2, y2) 갱신 전에 저장해둠.
        g[x2][y2] = pre; // 1. (x2, y2) 값이 이전 값으로 갱신됨.
        pre = dis; // 3. 다음 번 for 문에서 이전 값으로 활용되도록 갱신해줌.
    }
    return;
}
```

### 3. 다단계 칫솔 판매

풀이 시간: 31분

map을 활용할 때는 value에 맞게 변수명을 잘 지어야 안 헷갈린다.