# <center>프로그래머스 문제들 뽀개기</center>

## <center>2022 KAKAO TECH INTERNSHIP</center>

### 문제 3번 - 코딩 테스트 공부

#### 접근법

완전 탐색으로 풀이 시 시간 복잡도를 계산해보면

특정 알고력과 코딩력을 가지고 있을 때 (150^2) 알고력을 높이는 공부와 코딩력 높이는 공부와 문제들을 푸는 선택(1+1+100)을 할 수 있다.

대략 225e4의 값이 나와서 완탐으로 풀이할 수 있지 않을까 라고 생각하기 쉽지만 효율성 부분에서 점수를 얻지 못한다.

이 문제를 보고 dp라고 판단하는 것이 어려운 것 같다. 고수들의 설명을 여러 개 찾아보았는데 경험에 의한 감으로 표현했다.   

접근법도 어려운데 생각보다 다루어야할 코너케이스가 꽤 있다.

#### 첫 번째 시도

틀린 이유

`알고력 또는 코딩력 1을 놉이기 위해 1의 시간이 필요하다`는 조건은 DP 배열을 업데이트하는데 필요한 조건이다.

```c++
for (int i = alp; i <= a_max; i++) for (int j = cop; j <= c_max; j++) {
    dp[i][j] = (i - alp) + (j - cop);
}
```

나는 초기화할 때 수 많은 경우 중 한 가지 경우로 정해버렸기 때문에 완전히 틀린 방식이다.

#### 내가 어려웠던 부분 & 찾아서 배운 부분

1. dp 배열 크기 지정
   - 접근 범위 파악하기
2. 알고력과 코딩력을 모두 충족했을 때 가지치기
3. 초기알고력이 목표알고력보다 더 큰 경우 (코딩력도 마찬가지)
4. dp 배열을 초기화하는 범위
5. dp 배열 갱신 시 목표치를 넘는 한 파워에만 집중해 다른 한 파워에 리워드를 추가하지 않은 것 (대삽질, 1시간 걸림) 

도움을 많이 받은 설명: https://taehoung0102.tistory.com/211

### 문제 4번 - 등산 코스 정하기

#### 첫 번째 시도

**DFS로 풀이, 35분 걸림, 45.2점. 반절 이상은 TLE**

- DFS와 BFS의 시간 복잡도는 인접행렬로 구현했을 때 O(V^2), 인접리스트로 구현했을 때 O(V+E)의 시간복잡도를 갖는다.
- 각 시작점 최대 5만개에 대해서 DFS를 수행하게 되면 O(5e4 * 25e4) 당연히 시간 초과가 난다.
- 이 부분에 대해서 명확히 인지했다면 많은 시간을 줄였을 것이다. 잘 기억하자.

#### 두 번째 시도

**MST - Kruskal로 풀이, 구현 시간만 어림잡아 1시간, 87.1점.**

- `intensity가 최소가 되는 등산코스가 여러 개라면 그중 산봉우리의 번호가 가장 낮은 등산코스를 선택합니다.`이 조건을 풀이하지 못했다.
- 잘못된 접근

#### 세 번째 시도

**다익스트라로 풀이.**

- 카카오의 공식 해설과 몇 블로그의 글만 읽고 내가 작성해두었던 개념 노트를 참고해 구현해서 맞음
- **다익스트라 알고리즘만 정확히 이해하고 있으면 조금만 응용해서 풀 수 있다**고 한다.
- **임의의 출입구 A에서 어느 산봉우리로 가야 intensity가 최소가 되는지**로 기본 다익스트라를 변형시켰다.
- `출입구는 처음과 끝에 한 번씩, 산봉우리는 한 번만 포함되어야 합니다.`
  - 이 조건은 양방향 그래프를 단방향 그래프로 바꾸어 다루는 아이디어가 필요했다.

#### 여담

해설을 읽으면서 알고리즘 문제를 풀 때 변수에 대해 더 명확한 설명과 정의가 필요하다는 것을 깨닫는다. 또한 구현하는 로직을 말하면서 코드를 작성하는 연습을 꾸준히 해야겠다.

## 2022 KAKAO BLIND RECRUITMENT

### 신고 결과 받기

27분 소요

자료 구조 설정하고 다루는데 버벅거렸다. 여전히 cpp이 손이 안 익는 느낌이다...

공백을 기준으로 문자열 자르는 방법을 처음 배웠다. (`stringstream`, `#include <sstream>`) 

### k진수에서 소수 개수 구하기

소수 문제는 당연히 에라토스테네스의 체를 활용한다고 생각한 나의 고정관념을 깨부신 문제

40분동안 고민함... 문제를 자세히 봐야한다.

최대 N = 1000000을 가장 작은 진수인 3진수로 표현했을 때 13자리이다.

13자리의 숫자까지 에라토스테네스의 체로 소수인지 판별하면 공간복잡도와 시간복잡도 모두 초과한다.

이 문제는 소수 판별 호출 횟수가 매우 적기 때문에 < 13 숫자가 들어올 때마다 소수인지 판별하는 것이 적합한 해이다.

다만 N = 1e13이 될 수 있으므로 나누는 수를 2부터 √𝑁까지 살펴보는 O(√𝑁) 방법으로 소수 판정해야 한다.

### 주차 요금 계산

너가 생각하는 cpp 문법이 맞다. 조금 더 호다닥 작성해보자!

map의 value로 vector를 사용하고 싶단 생각을 많이 했다. 

검색해보니 사용할 수가 있다. 다시 바꿔서 작성해보자